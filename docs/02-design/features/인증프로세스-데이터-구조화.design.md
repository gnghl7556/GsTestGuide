# Design: 인증프로세스 데이터 구조화

> **Feature**: 인증프로세스-데이터-구조화
> **Phase**: Design
> **Created**: 2026-02-10
> **Plan Reference**: `docs/01-plan/features/인증프로세스-데이터-구조화.plan.md`

---

## 1. 설계 개요

하드코딩된 프로세스 데이터를 `content/` 폴더의 마크다운 파일로 분리하고,
Vite 빌드 시 이를 파싱하여 기존 TypeScript 타입으로 변환하는 구조를 설계한다.

### 데이터 흐름

```
[content/*.md]          ← 옵시디언에서 편집
       │
       ▼ (빌드 타임)
[Vite Plugin]           ← content/ 스캔 + gray-matter 파싱
       │
       ▼
[virtual module]        ← virtual:content/process, virtual:content/defects
       │
       ▼
[기존 컴포넌트]          ← import { REQUIREMENTS_DB } from 'virtual:content/process'
                          타입 동일: Requirement[], DefectReference[]
```

---

## 2. 마크다운 파일 스키마 정의

### 2.1 프로세스 항목 (process/*.md)

#### Frontmatter 스키마

```yaml
---
id: string            # 고유 ID (예: SETUP-01)
phase: string         # 7단계 중 하나 (시험준비|시험착수|초기시험|결함리포트|패치회귀|인증위심사|시험종료)
title: string         # 항목 제목
order: number         # 단계 내 정렬 순서
---
```

#### 본문 구조 (H2 섹션 기반 파싱)

```markdown
## 설명
자유 텍스트

## 체크포인트
- [ ] 항목1
- [ ] 항목2

## 증빙 예시
- 항목1
- 항목2

## 합격 기준
자유 텍스트

## 참조 문서
| 문서명 | 종류 | 설명 |
|--------|------|------|
| 시험 합의서 | file | 설명 |

## 참조 정보
| 항목 | 내용 | 링크 |
|------|------|------|
| 담당자 | 이예정 전임 | |
| 링크 | 구글 시트 | https://... |

## 담당자
| 역할 | 이름 | 연락처 |
|------|------|--------|
| 자리 배정 | 이예정 전임 | 010-5110-4917 |

## TIP
> 실무 팁 또는 주의사항
```

### 2.2 결함 사례 (defect-references/*.md)

#### Frontmatter 스키마

```yaml
---
category: string      # 품질특성 (기능적합성|성능효율성|사용성|신뢰성|보안성|유지보수성|이식성|호환성|일반적 요구사항)
---
```

#### 본문 구조 (반복 H3 블록)

```markdown
### 가상 PC 할당 기능 오류
- **심각도**: H
- **빈도**: A
- **설명**: 사용자 그룹 관리 메뉴를 통한 가상 PC 할당 시도 시...

### 선택 기능 오류
- **심각도**: H
- **빈도**: A
- **설명**: 개인 전용 PC 사양 변경 팝업창에서...
```

### 2.3 실행 규칙 (rules/*.md)

#### execution-gate.md

```yaml
---
type: execution-gate
---
```

```markdown
## 분기 조건

### 회귀 테스트 미완료 시
- 보안 테스트: disabled
- 성능 테스트: disabled

### 파생 결함 발견 시
- 보안 테스트: disabled
- 성능 테스트: disabled (2차 패치 이후로 연기)

### 파생 결함 없음
- 보안 테스트: enabled
- 성능 테스트: enabled

### 4차 확정(최종) 이후
- 모든 수행 단계: blockedByFinalization
```

### 2.4 카테고리 테마 (theme/categories.md)

```yaml
---
type: categories
---
```

```markdown
## 시험준비
- bg: bg-emerald-200
- text: text-emerald-700
- border: border-emerald-200

## 시험착수
- bg: bg-teal-200
- text: text-teal-700
- border: border-teal-200

## 초기시험
- bg: bg-indigo-200
- text: text-indigo-700
- border: border-indigo-200

## 결함리포트
- bg: bg-sky-200
- text: text-sky-700
- border: border-sky-200

## 패치회귀
- bg: bg-amber-200
- text: text-amber-700
- border: border-amber-200

## 인증위심사
- bg: bg-violet-200
- text: text-violet-700
- border: border-violet-200

## 시험종료
- bg: bg-slate-200
- text: text-slate-700
- border: border-slate-200
```

---

## 3. 파서 설계

### 3.1 모듈 구조

```
src/lib/content/
├── index.ts              ← 통합 export (getProcessItems, getDefectRefs, ...)
├── parseProcessItem.ts   ← 프로세스 항목 MD → Requirement 변환
├── parseDefectRef.ts     ← 결함 사례 MD → DefectReference[] 변환
├── parseRules.ts         ← 실행 규칙 MD → ExecutionGateConfig 변환
├── parseCategories.ts    ← 카테고리 테마 MD → CategoryTheme[] 변환
└── markdownUtils.ts      ← H2/H3 섹션 추출, 테이블 파싱, 리스트 파싱 유틸
```

### 3.2 핵심 파싱 함수

#### markdownUtils.ts

```typescript
// H2 섹션 분리: "## 체크포인트" → { heading: "체크포인트", content: "..." }
export function extractSections(markdown: string): Section[];

// 마크다운 리스트 → string[]
// "- [ ] 항목1\n- [ ] 항목2" → ["항목1", "항목2"]
export function parseCheckboxList(content: string): string[];

// 마크다운 리스트 → string[]
// "- 항목1\n- 항목2" → ["항목1", "항목2"]
export function parseBulletList(content: string): string[];

// 마크다운 테이블 → Record<string, string>[]
export function parseTable(content: string): Record<string, string>[];
```

#### parseProcessItem.ts

```typescript
import matter from 'gray-matter';
import type { Requirement } from '../../types';

export function parseProcessItem(fileContent: string): Requirement {
  const { data: frontmatter, content } = matter(fileContent);
  const sections = extractSections(content);

  return {
    id: frontmatter.id,
    category: mapPhaseToCategory(frontmatter.phase),
    title: frontmatter.title,
    description: findSection(sections, '설명')?.content ?? '',
    checkPoints: parseCheckboxList(findSection(sections, '체크포인트')?.content ?? ''),
    evidenceExamples: parseBulletList(findSection(sections, '증빙 예시')?.content ?? ''),
    passCriteria: findSection(sections, '합격 기준')?.content?.trim() ?? '',
    requiredDocs: parseRequiredDocsTable(findSection(sections, '참조 문서')?.content),
    relatedInfo: parseRelatedInfoTable(findSection(sections, '참조 정보')?.content),
    keywords: [], // frontmatter에서 optional로 추가 가능
  };
}

// 7단계 phase → 기존 RequirementCategory 매핑
function mapPhaseToCategory(phase: string): RequirementCategory {
  const map: Record<string, RequirementCategory> = {
    '시험준비': 'SETUP',
    '시험착수': 'SETUP',
    '초기시험': 'EXECUTION',
    '결함리포트': 'EXECUTION',
    '패치회귀': 'EXECUTION',
    '인증위심사': 'COMPLETION',
    '시험종료': 'COMPLETION',
  };
  return map[phase] ?? 'SETUP';
}
```

#### parseDefectRef.ts

```typescript
import matter from 'gray-matter';
import type { DefectReference } from '../../types';

export function parseDefectRefFile(fileContent: string): {
  category: string;
  items: DefectReference[];
} {
  const { data: frontmatter, content } = matter(fileContent);
  const h3Blocks = extractH3Blocks(content);

  return {
    category: frontmatter.category,
    items: h3Blocks.map((block) => ({
      summary: block.heading,
      description: extractBoldValue(block.content, '설명'),
      severity: extractBoldValue(block.content, '심각도') as 'H' | 'M' | 'L',
      frequency: extractBoldValue(block.content, '빈도') as 'A' | 'I',
    })),
  };
}
```

---

## 4. Vite 플러그인 설계

### 4.1 플러그인 구조

```typescript
// vite-plugin-content.ts
import { Plugin } from 'vite';
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const CONTENT_DIR = 'content';
const VIRTUAL_PREFIX = 'virtual:content/';

export function contentPlugin(): Plugin {
  return {
    name: 'vite-plugin-content',
    resolveId(id) {
      if (id.startsWith(VIRTUAL_PREFIX)) {
        return '\0' + id;  // Vite virtual module convention
      }
    },
    load(id) {
      if (id === '\0virtual:content/process') {
        return generateProcessModule();
      }
      if (id === '\0virtual:content/defects') {
        return generateDefectsModule();
      }
      if (id === '\0virtual:content/rules') {
        return generateRulesModule();
      }
      if (id === '\0virtual:content/categories') {
        return generateCategoriesModule();
      }
    },
    handleHotUpdate({ file, server }) {
      // content/ 폴더 파일 변경 시 HMR 트리거
      if (file.includes(CONTENT_DIR)) {
        const modules = [
          server.moduleGraph.getModuleById('\0virtual:content/process'),
          server.moduleGraph.getModuleById('\0virtual:content/defects'),
        ].filter(Boolean);
        return modules;
      }
    }
  };
}
```

### 4.2 Virtual Module 출력 형태

```typescript
// virtual:content/process 가 반환하는 코드
export const REQUIREMENTS_DB = [
  {
    id: "SETUP-01",
    category: "SETUP",
    title: "시험 확인",
    description: "PL 메일에서 시험번호...",
    checkPoints: ["PL 메일 확인", "첨부자료 확인"],
    // ...기존 Requirement 타입과 동일
  },
  // ...
];
```

### 4.3 TypeScript 타입 선언

```typescript
// src/types/virtual-content.d.ts
declare module 'virtual:content/process' {
  import type { Requirement } from './checklist';
  export const REQUIREMENTS_DB: Requirement[];
}

declare module 'virtual:content/defects' {
  import type { DefectReference } from '../features/defects/data/defectReferences';
  export const DEFECT_REFERENCES: Record<string, DefectReference[]>;
}

declare module 'virtual:content/rules' {
  export const EXECUTION_GATE_CONFIG: {
    regressionItemId: string;
    securityItemId: string;
    performanceItemId: string;
  };
}

declare module 'virtual:content/categories' {
  export const CATEGORIES: Array<{ id: string; name: string }>;
  export const CATEGORY_THEMES: Record<string, {
    bg: string; border: string; text: string;
    lightBg: string; activeBorder: string; ring: string;
    badgeBg: string; badgeText: string;
  }>;
}
```

---

## 5. 마이그레이션 설계

### 5.1 기존 import 교체 매핑

| 기존 import | 변경 후 import |
|-------------|---------------|
| `from '../data/requirements'` | `from 'virtual:content/process'` |
| `from '../data/constants'` | `from 'virtual:content/categories'` |
| `from '../defects/data/defectReferences'` | `from 'virtual:content/defects'` |

### 5.2 영향받는 파일 목록

| 파일 | 사용 데이터 | 변경 내용 |
|------|------------|----------|
| `src/utils/checklistGenerator.ts` | REQUIREMENTS_DB | import 경로 변경 |
| `src/features/checklist/utils/executionGate.ts` | 하드코딩 ID | rules config에서 읽기 |
| `src/features/defects/components/DefectReportForm.tsx` | DEFECT_REFERENCES | import 경로 변경 |
| `src/data/constants.ts` | CATEGORIES, CATEGORY_THEMES | 삭제 → virtual module |
| `src/data/requirements.ts` | REQUIREMENTS_DB | 삭제 → virtual module |
| `src/features/defects/data/defectReferences.ts` | DEFECT_REFERENCES | 삭제 → virtual module |

### 5.3 삭제 대상 파일

- `src/data/requirements.ts`
- `src/data/constants.ts`
- `src/features/defects/data/defectReferences.ts`

### 5.4 기존 타입 유지

아래 타입 파일은 **변경하지 않음** (호환성 유지):
- `src/types/checklist.ts` (Requirement, ChecklistItem, etc.)
- `src/types/models.ts` (DefectSeverity, DefectFrequency, etc.)

---

## 6. 구현 순서

```
Phase 1: 콘텐츠 파일 생성
├─ 1-1. content/ 폴더 구조 생성
├─ 1-2. 기존 requirements.ts → 마크다운 변환 (7단계 구조)
├─ 1-3. 기존 defectReferences.ts → 마크다운 변환
├─ 1-4. 기존 constants.ts → categories.md 변환
└─ 1-5. execution-gate 규칙 → rules/execution-gate.md

Phase 2: 파서 구현
├─ 2-1. markdownUtils.ts (섹션/리스트/테이블 파서)
├─ 2-2. parseProcessItem.ts
├─ 2-3. parseDefectRef.ts
├─ 2-4. parseRules.ts
└─ 2-5. parseCategories.ts

Phase 3: Vite 플러그인
├─ 3-1. vite-plugin-content.ts 기본 구조
├─ 3-2. virtual module 생성 로직
├─ 3-3. HMR 지원
├─ 3-4. virtual-content.d.ts 타입 선언
└─ 3-5. vite.config.ts에 플러그인 등록

Phase 4: 마이그레이션
├─ 4-1. import 경로 일괄 교체
├─ 4-2. executionGate.ts 하드코딩 ID → config 참조
├─ 4-3. 기존 하드코딩 파일 삭제
└─ 4-4. 빌드 + 동작 검증

Phase 5: 검증
├─ 5-1. 빌드 성공 확인
├─ 5-2. 기존 UI 기능 동작 확인
├─ 5-3. content/ 파일 수정 → HMR 반영 확인
└─ 5-4. 옵시디언에서 content/ 열람 확인
```

---

## 7. 의존성

### 새로 설치할 패키지

```bash
npm install --save-dev gray-matter
```

> `remark`/`unified`는 사용하지 않음. H2/H3 기반 단순 파싱으로 충분하며, 의존성을 최소화한다.
> `gray-matter`만으로 frontmatter + 본문 분리 후, 정규식 기반 섹션 파싱으로 처리한다.

---

## 8. 설계 결정 사항

| 결정 | 선택 | 이유 |
|------|------|------|
| 파싱 방식 | 빌드 타임 (Vite Plugin) | 런타임 성능 영향 없음, 타입 안전 |
| 마크다운 파서 | gray-matter + 정규식 | 의존성 최소화, 구조가 단순함 |
| 본문 구조 | H2 섹션 기반 | 옵시디언에서 자연스러움, 파싱 단순 |
| 7단계 → 4카테고리 매핑 | 코드 내 매핑 함수 | 기존 UI 호환성 유지 |
| 결함 사례 형식 | H3 블록 반복 | 각 사례가 독립적, 추가/삭제 용이 |
| 옵시디언 링크 | 미사용 ([[]] 금지) | 빌드 파싱 단순화 |

---

## 9. 성공 기준

- [ ] `content/` 마크다운 수정 → `npm run dev`에서 HMR로 즉시 반영
- [ ] `npm run build` 성공, 기존 UI 동작 정상
- [ ] 옵시디언에서 `content/` 폴더를 Vault로 열면 자연스러운 탐색 가능
- [ ] `gray-matter` 외 추가 의존성 없음
- [ ] 기존 `Requirement`, `DefectReference` 타입 인터페이스 변경 없음
